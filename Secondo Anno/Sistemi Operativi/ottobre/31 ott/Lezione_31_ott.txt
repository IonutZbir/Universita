Sincronizzazione e comunicazione tra processi

I processi hanno bisogno di un modo per comunicare in modo da condividere i dati durante l'esecuzione.
I processi hanno bisogno di un modo per sincronizzarsi per tener conto delle dipendenze, per evitare che si intralcino a vicenda

Race Conditions
Due processi "corrono" insieme per ottenere l'accesso ad un risorsa.
Requisiti per evitare "Race Conditions":

Regione Critica: zona di istruzioni nella quale un'unico processo/thread puo entrarci

1. Due processi non possono trovarsi contemporaneamente all'interno delle rispettive regioni critiche
2. Non si possono fare ipotesi sulla velocità o sul numero di CPU
3. Nessun processo in esecuzione a di fuori della propria regione critica puo bloccare altri processi
4. Nessun processo deve aspettare all'infinito per entrare nella propria regione critica

Non Soluzioni:
- Disabilitare gli interrupt, impedisce semplicemente che la CPU possa essere riallocata. Funziona solo per sistemi a CPU singola
- Bloccare le variabili, proteggere le regioni critiche con variabili 0/1. Le 'corse' si verificano ora sulle variabili di blocco.

La Mutua Esclusione

Un processo A entra nella regione critica, gli altri processi, per esempio un processo B deve aspettare che A finisca l'esecuzione del blocco di istruzioni per entrare a sua volta nella regione critica.

1. Busy Waiting

# Processo A
while(TRUE){
  while(turn != 0); // turn è la variabile globale, un ciclo che non fa nulla, oltre al controllo
  // nel momento che turn == 0, il thread esegue critical_region()
  // turn viene impostato a 0 nel momento in cui B esce dalla regione critica
  critcal_region();
  turn = 1; // imposta turn = 1, quindi esce dalla regione critica è permette a B di entrarci
  noncritical_region();  
}

#Processo B
while(TRUE){
  while(turn != 1); // turn è la variabile globale, un ciclo che non fa nulla, oltre al controllo
  // nel momente che turn == 1, il thread esegue critical_region()
  // turn viene impostato a 1 nel momento in cui A esce dalla regione critica
  critcal_region();
  turn = 0; // imposta turn = 0, quindi esce dalla regione critica è permette ad A di entrarci
  noncritical_region(); 
}

Purtroppo, questa è un altra non soluzione perche:
- Non permette ai processi di entrare nelle loro regioni critiche per due volte di seguito.
- Un processo fuori dalla regione critica può effettivamente bloccarne un altro

while(turn != 1/0): busy waiting, il thread non sta realmente in un stato di waiting, ma è comunque assegnato alla CPU, che per un tempo indeterminato esegue controlla la condizione all'interno dell'while  

2. Busy Waiting: Peterson's Algorithm

Alice e Bob vogliono usare un'unica postatione computer in un ufficio. Ma ci sono delle regole:
1. Solo una persona puo usare il computer alla volta.
2. Se entrambi vogliono usarlo contemporaneamente, devono decidere chi va per primo.

Idea:
- Alice e Bob devono segnalare il loro interesse a usare il computer.
- Se l'altro non è interessato, la persona interessata puo usarlo subito.
- Se entrambi mostrano interesse, registrano il loro nome su un foglio. Ma se scrivono quasi allo stesso tempo, l'ultimo nome sul foglio ha precedenza.
  Perche: garantisce che sempre uno avra scritto e l'ultimo sara quello che si prende la risorsa.
- La persona che non ha la precedenza aspetta finche l'altra ha finito.
- Una volta finito, la persona che ha usato il computer segnala che ha finito, e l'altra puo iniziare.

#Algorithm
#define N 2 // numero di processi

int turn; // a chi tocca?
int interested[N] // tutti i valori inizialmente 0 [FALSE]

void enter_region(int process){ // process è 0 o 1
  int other;  // numero dell'altro processo
  other = 1 - process;  // l'opposto del processo
  interested[process] = TRUE; // mostra che si è interessati
  turn = process; // imposta il flag
  // tra interested[process] = TRUE e il while a livello di CPU puo passare anni, quindi nel mentre l'altro processo puo interessarsi alla risorsa
  while(turn == process && interested[other] == TRUE) // istruzione NULL
  // aspetto affinche other perde l'interesse alla risorsa.
}
void leave_region(int process){ // process: chi esce
  interested[process] = FALSE;  // indica l'uscita dalla regione critica
}

TSL e XCHG

- Istruzione TSL (Test and Set Lock)
E presente in computer con piu processori. Legge il contenuto della memoria "lock", salva un valore non zeo, e blocca altre CPU da accesso alla memoria.
Purtroppo anche disabilitando gli interrupt su un processore non c'è garanzia che un processo "faccia danni" da un'altra CPU e quindi, blocchiamo tutti fino al termine dell'esecuzione di TSL.
Se devo aggire su una variabile, addirittura blocco tutti gli altri ad aggire sulla variabile. Vene fatto solo per operazioni atomiche, come per assegnare un valore.

Funzionamento:
Quando lock è 0, un processo puo impostare lock a 1 con TSL e accedere alla memoria condivisa. Al termine, il processo ressetta lock a 0.
Metodo per gestire Regioni Critiche:
- Processi chiamano enter_region prima di entrare nella regione critica e leave_region dopo.
- Se chiamati correttamente, garantisce la mutua esclusione.
- Se usati in modo errato, la mutua esclusione fallisce.

#Codice Assembly
enter_region:
  TSL REGISTER, LOCK // copia il lock nel registro e lo imposta a 1
  CMP REGISTER, #0 // il lock era 0?
  JNE enter_region // se non era 0, il lock era stato impostato, per cui ri-esegui il ciclo

  RET // torna al chiamante, si è entrati nella regione critica
leave_region:
  MOVE LOCK, #0 // memorizza 0 il lock
  RET // torna al chiamante


- Istruzione XCHG
Scambia i contenuti di due posizioni atomicamente. Usata in tutte le CPU x86 Intel per sincronizzazione di basso livello.

Problema:
Nonostante con l'algoritmo di Peterson funzioni, rimane il problema dello speco delle risorse causato dal busy waiting, il processo tiene occupata la CPU in attesa di poter entrare nella sua regione critica (spin lock).
Soluzione:
Lasciare che un processo in attesa di entrare nella sua regione critica restituisca volontariamente la CPU allo scheduler.

void sleep(){
  set own state to BLOCKED;
  give CPU to scheduler;
}

void wakeup(process){
  set state of process to READY;
  give CPU to scheduler;
}

Produttore-Consumatore

Nel problema del produttore-consumatore, due proessi condividono un buffer di dimensioni fisse.
Il produttore inserisce informazioni nel buffer, mentre il consumatore le preleva.
In produttore si addormenta (entra in modalità "sleep") se il buffer è pieno e viene risvegliato ("wakeup") quando il consumatore preleva i dati.
Analogamente, il consumatore dorme se il buffer è vuoto e viene risvegliato quando il produttore inserisce dati.

#define N 100
int count = 0;

void producer(void){
  int item;
  while(TRUE){
    item = produce_item();
    if(count == N) sleep(); // se ho prodotto N elementi vado in sleep (libero la CPU)
    insert_item(item); // se ci sono <N elementi allora continuo a produrli
    count++; // aggiorno il contatore
    if(count == 1) wakeup(cons) // se c'e almeno un prodotto sveglio il consumatore
  }
}

void consumer(void){
  int item;
  while(TRUE){ 
    if(count == 0) sleep() // se non ci sono elementi, vado in sleep (libero la CPU)
    item = remove_item(); // se c'e almeno un elemento lo rimuovo
    count--; // aggiorno il contatore
    if(count == N - 1) wakeup(prod); // se ci sono <N elementi allora sveglio il produttore
    consume_item(item);
  }
}

Problema: il produttore potrebbe svegliare il consumatore un attimo prima di andare in sleep(), e nessuno lo risveglierebbe piu, perche non potendo piu consumare, il produttore non sa se deve produrre o no.

Semafori

Fondamentalmente il semaforo è una variabile che puo essere 0 (nessun wakeup) oppure un valore positivo (wakeup in attesa) e su questa variabile si possono eseguire le seguenti operazioni:
- down
  Se il valore del semaforo è maggiore di zero, questo valore viene decrmentato, e il processo continua la sua esecuzione.
  Se il valore del semaforo è 0, il processo che ha invocato down viene bloccato e messo in una coda di attesa associata al semaforo (va a dormire, sleep()).

- up
  Se il valore è 0, ci sono processi nella coda di attesa, vengono "svegliati" (eventualmente per entrare in competizione ed eseguire di nouvo down).
  In ogni caso, il valore viene incrementato e il processo continua la sua esecuzione.

Atomicita: Le operazioni sui semafori sono "indivisibili", evitando conflitti
Problma Produttore-Consumatore: Uso dei semafori per gestire accesso e capacità di un buffer.
- Tipi di semafori
  mutex (mutual exclusion, accesso esclusivo).
  full (tutti i posti occupati).
  empty (tutti posti liberi).
-Uso
  mutex previene eccessi simultanei, full e empty coordinano attività.
{6.2_produce_consumer_semaphore.c}

Problema scrittori e lettori 

Regola: Ci sono tanti lettori(consumer) e un solo scrittore(producer)
Esempio: Si possono avere molteplici letture su un database, ma solo un singolo scritore.
Funzionamento Sintetico: 
    - Il primo lettore blocca l'accesso al database.
    - Lettori successivi incrementano un contatore.
    - L'ultimo lettore libera l'acccesso al database cosi lo scrittore può svolgere il suo lavoro.
{6.3_reader_writer_semaphore.c}
Uso semafori: sincronizzare piu processi tra loro.

Mutua esclusione: Mutex

Un "mutex" è una versione esplicita e semplicifacata dei semafori, usata per gestire la mutua esclusione di risorse o codice condiviso, quando non bisogna contare accessi e altri fenomeni.
Può essere in due stati:
- locked (bloccato)
- unlocked (sbloccato)
Un bit basta per rappresentarlo, ma spesso viene usato un intero (0 - unlocked, altri - locked)
Due procedure principali: mutex_lock e mutex_unlock
- Quando un thread vuole accedere a una regione critica, chiama mutex_lock.
- Se il mutex è unlocked, il thread può entrare; se è locked, il thread attende.
- Al termine dell'accesso, il thread chimata mutex_unlock per liberare la risorsa.
- IMPORTANTE: non si utilizza il busy waiting. Se un thread non puo acquisire un lock, chiama thread_yield per cedere la CPU ad un altro thread.
- I mutex possono essere implementati nello spazio utente con istruzioni come TLS e XCHG
- Alcuni pacchetti di thread offrono mutex_trylock che, tenta di acquisire il lock o restituisce un errore, senza bloccare. Offre la possibilita di provare a prendere lock, se non è gia occupato non si blocca ma continua ad eseguire altro, non sprecando tempo.
- I mutex sono efficaci quando i thread operano in uno spazio degli indirizzi comune.
- La condivisione di memoria tra processi può essere gesitita tramite il kernel o con l'aiuto di sistemi operativi che permettono la condivisione di parti dello spazio degli inidirizzi.
- L'efficienza nella sincronizzazione diventa cruciale con l' aumento del parallelismo
- Spin lock e mutex con busy waiting: efficaci per attese brevi, ma sprecano CPU per attese lunghe.
- Passaggio al kernel per bloccare processi è oneroso se le contese sono poche.
- Soluzione: Futex (Fast User Space Mutex), combina il meglio di entrambi gli approcci.

Mutexes in Pthead
La libreria Posix Pthead fornisce funzioni per sincronizzazione tra thread.
Il mutex è una variabile che puo essere locked o unlocked ed è utilizzato per proteggere le regioni critiche.
Il thread tenta di bloccare (lock) un mutex per accedere alla regione critica. Se mutex è unlocked, l'accesso è immediato e atomico. Se locked il thead attende.

Semafori o mutex?
- Finalità
  Mutex: E' utilizzato principalmente per garantire l'esclusione mutua. E' destinato a proteggere l'accesso a una risorsa condivisa, garantendo che una solo thead possa accedervi alla volta.
  Semaforo: Può essere usato per controllare l'accesso a una risorsa condivisa, ma è anche spesso usato per la sincronizzazione tra thread.

- Semantica
  Mutex: Di solito ha una semantica di "proprietà", il che significa che solo il thread che ha acquisito il mutex può rilascirarlo
  Semaforo: Non ha una semantica di "proprietà". Qualsiasi thead può aumentare o diminuire il conteggio del semaforo, indipendentemente da chi lo ha modificato l'ultima volta.

- Casistica
  Per l'esclusione mutua: Un mutex è generalmente preferibile. E' più semplice (di solito ha operazioni di lock e unlock) e spesso offre una semantica più rigorosa e un comportamento più prevedibile.
  Per la sincronizzazione tra thread: Un semaforo può essere più adatto, specialmente quando si tratta di coordinare tra diversi thread o di gestire risorse con un numero limitato di istanze disponibili.
{6.4_produce_consumer_mutex.c}




