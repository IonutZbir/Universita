SCHEDULING

-> Introduzione allo scheduling

In un sistema multiprogrammato molteplici processi e thread competono per la CPU, quindi è necessario scegliere a quale processo o thread assegnare la CPU. La parte del sistema operativo che effettua lo scheduling è detto scheduelere l'algoritmo che utilizza si chiama algoritmo di scheduling. 

Molti problemi di scheduling per processi valgono anche per thread, nel caso in cui i thread sono gestiti dal kernel.

Nei sistemi batch storici, lo scheduling era lineare, ovvero i job venivano eseguiti in modo sequenziale. 
Con la multiprogrammazione, lo scheduling è diventato complessi a causa della concorrenza tra utenti.

Costi in termini di tempo del scheduling.
Lo scambio di processi (context switch) è oneroso.
- Cambio da modalità utente a modalità kernel.
- Salvataggio dello stato del processo.
- Esecuzione dell'algoritmo di scheduling.
- Aggiornamento della MMU con la nuova mappa della memoria.
- Potenziale invalidazione della memoria cache.
Tutte queste operazioni possono consumare tempo alla CPU.

# Problema di Scheduling dei Processi

I processi alternano fasi di elaborazione CPU-intense con richieste di I/O.
In genere un processo utilizza la CPU per un certo periodo senza interrompersi, poi fa una chiamata di sistema per leggere da un file o scrivere un file.
Quando la chiamata di sistema è completa, riprende a usare la CPU fino a quando ha bisogno di leggere o di scrivere altri dati, e così via.
Quando la CPU copia/preleva dati dalla RAM si parla di elaborazione e non di I/O.

Ci sono due tipologie di processi:
1. Processi Compute-bound (CPU-bound): Burst di CPU lunghi, attese di I/O infrequenti, quindi passano molto tempo nella CPU.
2. Processi I/O-bound: Burst di CPU brevi, attese di I/O frequenti. Sono tali a causa della bassa necessità di calocli, non della durata delle richieste di I/O.
{immagine}

Con CPU più veloci, i processi tendono a essere più I/O-bound. Ultimamente le CPU non stanno avanzando rapidamente in velocità, perchè l'aumento di velocità produce troppo calore e nemmeno gli hard disk aumentato la velocità. 
Gli SSD sostituiscono gli hard disk nei vari PC desktop, però nei grandi data center vengono ancora utilizzati gli hard disk, per il loro basso costo per bit.
Perciò lo scheduling dipende molto dal contesto, un algoritmo di scheduling per un PC personale potrebbe non andare bene per un server, etc...

# Quando Effetuare lo Scheduling

- Creazione Nuovo Processo
Lo scheduler deve decidere quale processo tra figlio e padre scegliere per l'esecuzione. Essendo entrambi in stato di ready, si tratta di una normale decisione di scheduling, che puo andare bene in entrambe le direzioni.

- Uscita di un Processo 
Se un processo esce, occorre scegliere un altro dai processi pronti.  Se nessuno è pronto, occorre eseguire un processo inattivo del sistema.

- Blocco di un Processo 
Se un processo si blocca (I/O, semaforo, etc...), occorre selezionarne un altro.

- Interrupt di I/O
na decisione di scheduling va presa quando si verifica un interrupt di I/O. Se l’interrupt proveniva da un dispositivo di I/O che adesso ha terminato il lavoro, qualche processo bloccato in attesa del dispositivo di I/O potrebbe ora essere pronto a partire.
Sta allo scheduler stabilire se eseguire il processo che è appena diventato pronto, quello che era in esecuzione al momento dell’interrupt o qualche altro processo.

# Tipologie di Algoritmi Scheduling e Prelazione

- Non Preemptive (Senza Prelazione)
sceglie un processo per eseguirlo e poi lo lascia semplicemente girare fino a quando si blocca (sia su un I/O o in attesa di un altro processo) o rilascia volontariamente la CPU. Anche se è eseguito per ore, non sarà sospeso forzatamente. In effetti durante gli interrupt del clock non vengono prese decisioni di scheduling. 
Dopo il completamento dell’elaborazione dell’interrupt del clock viene ripristinato il processo che era in esecuzione prima dell’interrupt, a meno che un processo di priorità più alta sia in attesa di un timeout ora soddisfatto.

- Preemptive (Con Prelazione)
sceglie un processo e lo lascia girare per un tempo massimo prefissato. Se alla fine dell’intervallo di tempo è ancora in esecuzione, il processo è sospeso e lo scheduler ne sceglie un altro da eseguire (se è disponibile).
Uno scheduling con prelazione richiede che vi sia un interrupt del clock alla fine dell’intervallo per restituire il controllo della CPU allo scheduler. Se non è disponibile il clock, lo scheduling senza prelazione rimane l’unica possibilità.

La prelazione non è rilevante solo per le applicazioni, ma anche per i kernel dei sistemi operativi, specie se monolitici. Oggi molti di essi hanno la prelazione; se non l’avessero, un driver male implementato o una chiamata di sistema molto lenta potrebbero intasare la CPU.
In un kernel con prelazione, invece, lo scheduler può forzare uno scambio di contesto per il driver o la chiamata troppo lenti.

# Categorie di Algoritmi di Scheduling

1. Batch 
2. Interrativo
3. Sistemi Real-Time







