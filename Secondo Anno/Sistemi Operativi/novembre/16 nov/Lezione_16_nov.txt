MEMORIA VIRTUALE

Mentre da un lato i registri base e limite possono essere utilizzati per creare l’astrazione degli spazi degli indirizzi, dall’altro sorge un nuovo problema: la gestione del bloatware, cioè del software sempre più “gonfio”. Le dimensioni della memoria sono in costante aumento, ma quelle dei software aumentano ancora più velocemente

L’idea alla base della memoria virtuale è che ogni programma ha un suo spazio degli indirizzi, suddiviso in parti chiamati pagine. Ogni pagina è un intervallo di indirizzi contigui. Queste pagine sono mappate sulla memoria fisica, ma per eseguire il programma non è indispensabile che tutte le pagine siano contemporaneamente nella memoria fisica. Quando il programma fa riferimento a una parte del suo spazio degli indirizzi che è nella memoria fisica, l’hardware esegue direttamente la mappatura necessaria. Quando il programma fa riferimento a una parte del suo spazio degli indirizzi che non è nella memoria fisica, il sistema operativo viene allertato, va a prelevare la parte mancante ed esegue nuovamente fallita.

Implementazioni diverse della memoria virtuale adottano scelte diverse rispetto a queste unità; oggi la maggior parte dei sistemi impiega una tecnica detta paging (paginazione) che prevede unità di dimensioni fisse, ad esempio di 4 KB. Una soluzione alternativa detta segmentazione usa come unità interi segmenti di dimensione variabile.

--> PAGINAZIONE

La maggior parte dei sistemi di memoria virtuale usa una tecnica chiamata paginazione o paging. Su qualsiasi computer i programmi fanno riferimento a un set di indirizzi di memoria.
quando un programma esegue un’istruzione come

MOV REG,1000

la esegue per copiare il contenuto dell’indirizzo di memoria 1000 in REG. Gli indirizzi possono essere generati usando indicizzazione, registri base e vari altri modi.

Questi indirizzi generati dal programma sono chiamati indirizzi virtuali e formano lo spazio degli indirizzi virtuali. Sui computer senza memoria virtuale, l’indirizzo virtuale è posto direttamente sul bus di memoria e provoca la lettura o la scrittura della parola della memoria fisica con lo stesso indirizzo. Quando è utilizzata la memoria virtuale, gli indirizzi virtuali non vanno direttamente al bus di memoria, ma a una MMU (Memory Management Unit, unità di gestione della memoria) che mappa gli indirizzi virtuali sugli indirizzi della memoria fisica (circuito presente nella CPU).

Lo spazio degli indirizzi virtuali è suddiviso in unità di dimensione fissa, chiamate pagine. Le unità corrispondenti nella memoria fisica sono chiamate frame o page frame. Le pagine e i frame sono della stessa dimensione; per esempio da 4 KB. Nei sistemi reali le pagine vanno da 512 byte fino a 64 KB.
{immagine}
64Kb di pagine vituali possono essere mappate in 8 frame, usando 16 bit per indirizzo.  I trasferimenti fra RAM e memoria non volatile sono sempre di pagine intere. Molti processori supportano più dimensioni di pagina, che possono essere mescolati e abbinati a discrezione del sistema operativo. Ad esempio, l’architettura x86-64 supporta pagine da 4 KB, 2 MB e 1-GB, e potremmo utilizzare le pagine da 4 KB per le applicazioni utente e una singola pagina da 1 GB per il kernel.

Esempi:

1. L’istruzione MOV REG,8192 è trasformata effettivamente in MOV REG,24576 poiché l’indirizzo virtuale 8192 (nella pagina virtuale 6) è mappato sul 24576 (nel frame fisico 24K–28K)
2. L’indirizzo virtuale 20500 dista 20 byte dall’inizio della pagina virtuale 3 (indirizzi virtuali da 20480 a 24575) e la sua mappatura sull’indirizzo fisico è 12288 + 20 = 12308.

Questa capacità di mappare le 16 pagine virtuali su uno qualsiasi degli 8 frame, impostando in modo appropriato la mappa della MMU, da sola non basta a risolvere il problema dello spazio degli indirizzi virtuali più grande della memoria fisica. Poiché abbiamo solo 8 frame fisici, solo otto delle pagine virtuali sono mappate sulla memoria fisica. Le altre, mostrate nella figura con una X, non sono mappate. Nell’hardware, un bit presente/assente tiene traccia di quali pagine sono presenti fisicamente in memoria.
Che cosa accade se, per esempio, il programma fa riferimento a indirizzi non mappati usando l’istruzione MOV REG,32780 che è il byte 12 all’interno della pagina virtuale 8 (che parte da 32768)? La MMU rileva che la pagina non è mappata (è contrassegnata da una X nella figura) e causa una trap della CPU verso il sistema operativo. Questa trap è chiamata page fault (errore di pagina). Il sistema operativo preleva un frame poco utilizzato e ne scrive il contenuto su disco (se non è già presente). Prende poi la pagina alla quale è stato appena fatto riferimento e la pone nel frame appena liberato, cambia la mappae riavvia l’istruzione che era in trap.

--> MMU
Guardiamo adesso all’interno della MMU per vedere come funziona e perché abbiamo scelto di usare una dimensione di pagina che sia una potenza di 2.
Nella figura viene mostrato un esempio di un indirizzo virtuale, 8196 (0010000000000100 in binario), mappato usando la mappa della MMU mostrata in figura. L’indirizzo virtuale di 16 bit in ingresso è suddiviso in un numero di pagina di 4 bit e un offset di 12 bit. Con 4 bit per il numero di pagina (bit usati per la conversione da indirizzo virtuale a indirizzo fisico), possiamo avere 16 pagine (2^4 pagine) e con 12 bit di offset (bit usati per scorrere all'interno delal pagina) possiamo indirizzare 4096 byte (4Kb) per pagina, ovvero 4Kb * 16 pagine = 64Kb per ogni processo.

Il numero di pagina è usato come indice nella tabella delle pagine che porta al numero di frame corrispondente alla pagina virtuale. Se il bit presente/assente è 0, avviene una trap al sistema operativo. Se il bit è 1, il numero di frame trovato nella tabella delle pagine viene copiato nei tre bit più significativi del registro di output, insieme all’offset di 12 bit che è copiato senza modifiche dall’indirizzo virtuale in arrivo. Insieme formano un indirizzo fisico di 15 bit. Il registro di output è poi posto sul bus di memoria come indirizzo fisico di memoria.

Com'è strutturata una voce all'interno della tabella delle pagine?
{immagine}
Nella figura è mostrato l’esempio di una voce della tabella delle pagine. La dimensione cambia a seconda del computer, ma quella usuale in un generico computer odierno è di 64 bit. Il campo più importante è il numero del frame (frame number): l’obiettivo della mappatura delle pagine è ottenere questo valore. Se la dimensione della pagina è 4 KB, per il numero del frame sono necessari solo i 52 bit più significativi1, e rimangono 12 bit per codificare altre informazioni sulla pagina. Ad esempio, il bit Presente/assente indica se la voce è valida e possa essere usata. Se questo bit è 0, la pagina virtuale cui appartiene la voce non è effettivamente in memoria. L’accesso alla voce della tabella delle pagine con questo bit impostato a 0 causa un page fault. 

I bit Protezione specificano quali tipi di accesso sono consentiti. Nella forma elementare questo campo contiene 1 bit, con 0 che significa lettura/scrittura e 1 per la sola lettura. Un’impostazione più sofisticata ha 3 bit, ogni bit per consentire lettura, scrittura ed esecuzione della pagina. Il bit Supervisor è in qualche modo correlato, e indica se la pagina sia accessibile soltanto al codice con privilegi, ovvero al sistema operativo (o supervisore) oppure anche ai programmi utente. Qualsiasi tentativo di accesso a una pagina supervisore da parte di un programma utente causa un page fault.

I bit Modificato e Riferimento tengono traccia dell’uso della pagina. Quando viene scritta una pagina, l’hardware imposta automaticamente il bit Modificato. Questo bit è valorizzato quando il sistema operativo decide di riutilizzare un frame. Se la sua pagina è stata modificata (cioè è “sporca”) deve essere riscritta sulla memoria non volatile. Se non è stata modificata (cioè è “pulita”) può essere abbandonata, poiché la copia su disco o SSD è ancora valida. Talvolta il bit è chiamato dirty bit poiché riflette lo stato della pagina.

Il bit Riferimento è impostato ogni qualvolta si faccia riferimento alla pagina, sia in lettura sia in scrittura. Serve per aiutare il sistema operativo a scegliere una pagina da “sfrattare” quando si verifica un page fault; le pagine inutilizzate sono più “sfrattabili” di quelle usate, e questo bit gioca un ruolo importante in molti degli algoritmi di sostituzione delle pagine che studieremo in seguito.

Per un processo, l'indirizzo in memoria della "sua" tabella delle pagine è scritto nel registro Page Table Base Register.


