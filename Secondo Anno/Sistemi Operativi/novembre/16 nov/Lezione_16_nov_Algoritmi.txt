--> ALGORITMI DI SOSTITUZIONE DELLE PAGINE
Quando si verifica un page fault, per far spazio alla pagina entrante il sistema operativo deve scegliere una pagina da sfrattare (rimuovere dalla memoria). Se la pagina da rimuovere è stata modificata mentre era in memoria, deve essere riscritta sulla memoria non volatile per aggiornare la copia su disco o SSD. Se invece la pagina non è stata modificata (per esempio perché contiene il codice eseguibile del programma), la copia su disco o SSD è già aggiornata e non c’è bisogno di riscrivere. La pagina da leggere sovrascrive semplicemente la pagina sfrattata.

Sarebbe possibile prendere una pagina a caso da rimuovere a ogni page fault, ma le prestazioni del sistema migliorano molto se si sceglie una pagina non particolarmente utilizzata. Se si sfrattasse una pagina usata frequentemente, con ogni probabilità dovrebbe essere riportata in memoria a breve, con il risultato di un ulteriore sovraccarico.

1. L'algoritmo ottimale di sostituzione delle pagine

Ciascuna pagina può essere etichettata con il numero di istruzioni da eseguire prima di ricevere un riferimento per la prima volta.
L’algoritmo di sostituzione ottimale indica che deve essere rimossa la pagina con, l’etichetta con il numero più alto. Se una pagina non sarà usata per 8 milioni di istruzioni e un’altra pagina per 6 milioni di istruzioni, rimuovere la prima allontana il page fault che la ricaricherebbe il più in là possibile.

Il solo problema di questo algoritmo è che è irrealizzabile. Al momento del page fault, il sistema operativo non ha modo di sapere in quale momento verrà fatto il prossimo riferimento a ciascuna delle pagine. Però eseguendo un programma su un simulatore, e tenendo traccia di tutti i riferimenti alle pagine, è possibile implementare una sostituzione delle pagine ottimale sulla seconda esecuzione, usando le informazioni sui riferimenti alle pagine raccolte durante la prima esecuzione. In questo modo è possibile confrontare le prestazioni degli algoritmi realizzabili con quelle del migliore algoritmo possibile, ad esempio, se un sistema operativo ottiene una prestazione inferiore dell’1% rispetto all’algoritmo ottimale, per quanto ci si sforzi alla ricerca di un algoritmo migliore si otterrà al massimo un miglioramento dell’1%.

2. Not Recently Used (NRU)
Al fine di consentire al sistema operativo la raccolta di statistiche utili sull’uso delle pagine, molti computer con memoria virtuale hanno due bit di stato, R e M, associati a ciascuna pagina. R viene impostato quando si fa riferimento alla pagina (in lettura o scrittura). M è im­postato quando la pagina viene scritta (cioè modificata). I bit sono contenuti in ciascuna voce della tabella delle pagine. I bit vengono aggiornati dall'hardware ad ogni accesso.

I bit R e M possono essere usati per costruire un algoritmo di paginazione semplice come il seguente. All’avvio di un processo, entrambi i bit di pagina di tutte le pagine sono impostati a 0 dal sistema operativo. Periodicamente (per esempio a ogni interrupt del clock), il bit R è ripulito, per contraddistinguere le pagine che non hanno avuto riferimenti recentemente da quelle che ne hanno avuti. Quando avviene un page fault, il sistema operativo ispeziona tutte le pagine e le divide in 4 categorie basate sui valori attuali dei loro bit R e M:

Classe 0: nessun riferimento, non modificata.
Classe 1: nessun riferimento, modificata.
Classe 2: riferimento, non modificata.
Classe 3: riferimento, modificata.

Le pagine di classe 1 sembrano a prima vista impossibili, ma appaiono quando un interrupt del clock azzera il bit R di una pagina di classe 3. Gli interrupt del clock non azzerano il bit M perché questa informazione è necessaria per sapere se la pagina deve essere riscritta su disco o meno. Azzerare R ma non M produce una pagina di classe 1. In altre parole, una pagina di classe 1 è stata modificata molto tempo fa e da allora non è stata più toccata.

L’algoritmo NRU (Not Recently Used) rimuove una pagina a caso dalla classe non vuota con il numero più basso.
I vantaggi sono: Semplicità, efficienza implementativi e prestazioni accettabili.

3. First-In, First-Out (FIFO)

Descrizione: FIFO è un algoritmo di paginazione che elimina la pagina più vecchia in memoria.
Implementazione: Il sistema operativo rimuove la pagina in testa alla lista (la più vecchia) durante un page fault, aggiungendo la nuova pagina in coda.
Problema: Nel contesto informatico, la pagina più vecchia potrebbe ancora essere frequentemente utilizzata (ricorsione), rendendo FIFO poco efficace.
Conclusione: A causa di queste limitazioni, FIFO è raramente utilizzato nella sua forma più semplice.

4. Seconda Chance

Una semplice modifica a FIFO che evita il problema di gettare una pagina usata di frequente consiste nel controllare il bit R del­la pagina più vecchia. Se è 0, la pagina è vecchia e inutilizzata e viene così sostituita immediatamente. Se R è 1, il bit viene azzerato, la pagina è posta in fondo all’elenco e il momento in cui è stata caricata in memoria viene aggiornato per farla sembrare appena arrivata. Poi la ricerca continua. L’operatività di questo algoritmo, detto seconda chance, è illustrata nella figura.
{immagine}
Supponiamo che si verifichi un page fault all’istante 20. La pagina più vecchia è A, arrivata al momento 0, all’inizio del processo. Se A ha il bit R azzerato, allora è rimossa dalla memoria, sia scrivendola su memoria non volatile (se è sporca) sia semplicemente scaricandola (se è pulita). Se invece il bit R è impostato, A viene portata in fondo alla lista e il suo “momento di caricamento” è reimpostato all’attuale (20). Anche il bit R è azzerato. La ricerca della pagina adatta prosegue con B. 

Quello che la seconda chance sta cercando è una vecchia pagina che non sia stata oggetto di riferimenti durante l’ultimo intervallo del clock. Se tutte le pagine hanno avuto riferimenti, la seconda chance degenera in un FIFO puro.

